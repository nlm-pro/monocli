import { cmdOptionType, cmdOption } from "./options";
import { SubProject } from "./SubProject";
import { Monorepo } from "./Monorepo";

export class CommandOptionError extends Error {
  constructor(public optionName: string | string[], message?: string) {
    super(message);
  }
}

export interface CommandOptionConfig {
  type: cmdOptionType;
  description: string;
  defaultValue?: cmdOptionType;
}

const optionToString = (
  name: string,
  { type, description, defaultValue }: CommandOptionConfig
): string => {
  // TODO: dash-case name
  let defaultStr = type === `string` ? `"${defaultValue}` : defaultValue;
  defaultStr =
    typeof defaultValue !== `undefined` ? `(default: ${defaultStr})` : ``;
  const typeStr = type !== `boolean` ? `<${type}>` : ``;

  return `--${name} ${typeStr}\t${description} ${defaultStr}`;
};

export abstract class Command {
  private singleMandatoryOptions: Map<string, CommandOptionConfig>;

  protected abstract readonly name: string;
  // FIXME: should be autogenerated from "raw options"
  protected abstract readonly usage: string;
  protected abstract readonly description: string;
  protected abstract readonly details: string;
  protected abstract readonly options: Map<string, CommandOptionConfig>;

  constructor(protected monorepo: Monorepo) {}

  protected get mandatoryOptions(): Map<string, CommandOptionConfig> {
    if (!this.singleMandatoryOptions) {
      this.singleMandatoryOptions = new Map(
        [...this.options].filter(
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          ([name, config]) => typeof config.defaultValue !== `undefined`
        )
      );
    }

    return this.singleMandatoryOptions;
  }

  get help(): string {
    let options = this.optionsHelp;
    options = options
      ? `Options:
${options}`
      : ``;

    return `
Usage: monocli ${this.name} ${this.usage} [options]

${this.description}

${this.details}

${options}
    `;
  }

  validate(options: Map<string, cmdOption>): void {
    const mandatoryOptionsPile = this.mandatoryOptions;
    for (const [optionName, optionConfig] of this.options) {
      if (typeof optionConfig.defaultValue !== `undefined`) {
        if (!options.has(optionName)) {
          throw new CommandOptionError(optionName, `missing mandatory option`);
        }
      } else {
        mandatoryOptionsPile.delete(optionName);
      }

      if (typeof options.get(optionName) !== optionConfig.type) {
        throw new CommandOptionError(optionName, `invalid type provided`);
      }
    }
    if (mandatoryOptionsPile.size > 0) {
      throw new CommandOptionError(
        [...mandatoryOptionsPile.keys()],
        `missing mandatory options`
      );
    }
  }

  abstract async run(
    options?: Map<string, cmdOption>,
    subProject?: SubProject | SubProject[]
  ): Promise<string | void>;

  private get optionsHelp(): string {
    const options = [...this.options];
    const firstOption = options.shift();

    if (typeof firstOption === `undefined`) {
      return ``;
    }

    return [...options].reduce(
      (prev, [name, config]) => `${prev}\n\t${optionToString(name, config)}`,
      `\t${optionToString(...firstOption)}`
    );
  }
}
